int COM_NN_D(struct DM_N n1, struct DM_N n2)			// сравнение двух натуральных чисел
{
	if (n1.l > n2.l) return 2;			// сравнeниe длины чисел	
	else
		if (n1.n < n2.n) return 1;

	for (int c = n1.l; c >= 0; c--)		// поразрядное сравнение, если длины равны
		if (n1.n[c] > n2.n[c]) return 2;
		else
			if (n1.n[c] < n2.n[c])	return 1;
	return 0;
// 2 -  первое число больше
// 1 -  второе число больше
// 0 -  числа равны
}

bool NZER_N_B(struct DM_N n1)	// проверка числа на ноль
{
	for (int c = 0; c < n1.l; c++)
	{
		if (n1.n[c] != 0)	return true;
	}
	return false;
}

int ADD_1N_N(struct DM_N n1) // добавление 1 к натуральному числу
{
	int c = 1;
	if (n1.n[n1.l - 1] != 9) // если последняя цифра не 9, то прибавляется 1
	{
		n1.n[n1.l - 1]++;
	}
	else
	{
		while ((n1.n[n1.l - c] == 9) && (c != n1.l)) // если последняя 9, то ищем неравную 9 и прибавляем 1
		{
			n1.n[n1.l - c] = 0;
			c++;
		}
	}

}

int ADD_NN_N(struct DM_N n1, struct DM_N n2)	// cложение натуральных фисел
{
	DM_N qq;
	if (COM_NN_D(n1, n2) == 2)
		qq.l = n1.l +1;
	else
		qq.l = n2.l + 1;

	for (int i = 0; i < qq.l; i++)
	{
		n1.n[i] += n2.n[i];						// суммируем последние разряды чисел
		n1.n[i + 1] += (n1.n[i] / 10);			// если есть разряд для переноса, переносим его в следующий разряд
		n1.n[i] %= 10;							// если есть разряд для переноса он отсекается
	}

	if (n1.n[qq.l - 1] == 0)
		qq.l--;
}

int SUB_NN_N(struct DM_N n1, struct DM_N n2)	// вычитание из первого большего натурального числа второго меньшего или равного
{
	DM_N qq;
	if (COM_NN_D(n1, n2) == 2)
	{				// если n1 > n2 
		for (int i = n1.l; i > n2.l; i--)
		{
			if (n1.n[i] - n2.n[i] >= 0)			// разность больше нуля
			{
				qq.n[i] = n1.n[i] - n2.n[i];	// вычитание  
			}
			else
			{
				n1.n[i - 1]--;					// занимаем 10 из следующего разряда, затем вычитаем
				n1.n[i] = n1.n[i] + 10;
				qq.n[i] = n1.n[i] - n2.n[i];
			}
		}
	}
	else if (COM_NN_D(n1, n2) == 1)				// если n2 > n1
	{
		for (int i = n2.l; i > n1.l; i--)
		{
			if (n2.n[i] - n1.n[i] >= 0)
			{
				qq.n[i] = n2.n[i] - n1.n[i];
			}
			else
			{
				n2.n[i - 1]--;
				n2.n[i] = n2.n[i] + 10;
				qq.n[i] = n2.n[i] - n1.n[i];
			}
		}
	}

	else										 //Если n1 = n2
	{
		qq.n = (short unsigned int*) realloc(qq.n, sizeof(short unsigned int));
		qq.l = 1;
		qq.n[0] = 0;
	}
	return qq;
}

void MUL_ND_N(struct DM_N n2, unsigned int k)		//умножение натурального числа на цифру
{
	DM_N qq;
	qq.l = n2.l + 2;

	for (int i = 0; i < n2.l; i++)
			qq.n[i] += n2.n[i] * k;

	for (int i = 0; i < qq.l; i++)
	{
		qq.n[i + 1] += qq.n[i] / 10;
		qq.n[i] %= 10;
	}

	while (qq.n[qq.l] == 0)
		qq.l--;
	return qq;
}

void MUL_Nk_N(struct DM_N& obj, unsigned int k)		// умножение натурального числа на 10 в степени k
{
	DM_N qq;							// для хранения старых значений
	qq.n = obj.n;
	qq.l = obj.l;

	int zero = 0;
	for (int i = qq.l - 1; i >= 0 && obj.n[i] == 0; i--)
		++zero;

	if (k > zero)
		obj.n = obj.n + k - zero;
	obj.n = new unsigned short[obj.l];

	for (int i = obj.l - 1; i >= 0; i--)
		if (i < k)
			obj.n[i] = 0;
		else
			obj.n[i] = qq.n[i - k];
}

void MUL_NN_N(struct DM_N n1, struct DM_N n2)					// умножение натурального числа на натуральное число
{
	DM_N qq;
	qq.l = n1.l + n2.l + 1;

	for (int i = 0; i < n1.l; i++)
		for (int j = 0; j < n2.l; j++)
			qq.n[i + j - 1] += n1.n[i] * n2.n[j];

	for (int i = 0; i < qq.l; i++)
	{
		qq.n[i + 1] += qq.n[i] / 10;
		qq.n[i] %= 10;
	}

	while (qq.n[qq.l] == 0)
		qq.l--;
}

void SUB_NDN_N(struct DM_N n1, struct DM_N n2, unsigned k)	 // вычитание из натурального числа другого числа помноженного на число, для неотрицательного результата
{
	int i;
	DM_N qq;
	MUL_ND_N(n2, k);
	if (COM_NN_D(n1, qq) != 1)
	{
		{
			for (i = 0; i < (qq.l - 1); i++)			 // проход по всем разрядам числа, начиная с последнего, не доходя до первого

				if (i < (qq.l - 1))				 // если текущий разряд чисел не первый
				{
					n1.n[i + 1]--;						 // в следующуем разряде большего числа занимаем 1.
					qq.n[i] += 10 + n1.n[i];					// в ответ записываем сумму значения текущего разряда большего числа и 10-ти

				}
				else									 // если текущий разряд чисел - первый
					qq.n[i] += n1.n[i];							// в ответ суммируем значение текущего разряда большего числа

			qq.n[i] -= n2.n[i];									// вычитаем значение текущего разряда меньшего числа

			if (qq.n[i] / 10 > 0)							 // если значение в текущем разряде двухразрядное
			{
				qq.n[i + 1]++;								// переносим единицу в старший разряд
				qq.n[i] %= 10;								// в текущем разряде отсекаем ее
			}
		}
		return qq;
	}
	else return 0;
}
}
