DM_P SUB_PP_P(DM_P p1, DM_P p2)//Вычитание многочленов
{
	DM_P res;           // результирующий многочлен
	unsigned int k = 0; // вспомогательная переменная
	res.c = NULL;       // массив c коэффициентами
	if (p1.m >= p2.m)   // если первый многочлен больше или равен второму
	{
		res.c = new DM_Q[p1.m]; // выделяем память под результ. многочлен
		res.m = p1.m;           // приравниваем степень результ. многочлена первому 
		for (unsigned int i = 0; i < p2.m; i++)
		{
			res.c[i] = SUB_QQ_Q(p1.c[i], p2.c[i]); // вычитаем коэффициенты
			k = i;
		}
		for (unsigned int i = k; i < p1.m; i++) // заполняем массив оставшимися коэффициентами 
		{
			res.c[i] = p1.c[i];
		}

	}
	else               // если второй многочлен больше первого
	{
		res.c = new DM_Q[p2.m]; // выделяем место под результирующий многочлен
		res.m = p2.m;           // приравниваем степень результирующего многочлена к степени второго многочлена
		for (unsigned int i = 0; i < p1.m; i++)
		{
			res.c[i] = SUB_QQ_Q(p2.c[i], p1.c[i]);  // вычитаем коэффициенты 
			k = i;
		}
		for (unsigned int i = k; i < p2.m; i++) // заполняем массив оставшимися коэффициентами
		{
			res.c[i] = p2.c[i];
		}
	}
	return res;
}